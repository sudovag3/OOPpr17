# Практическая работа 17


## Задача 1

Известно, что алгоритм sort не работает со списками. Поэтому для списков определена функция-член sort.  Также у списков существует функция-член unique, которая удаляет повторяющиеся последовательные элементы. Создайте список, заполните его некоторыми значениями и продемонстрируйте работу sort и unique.
Удалите из полученного списка заданный пользователем элемент. Воспользуйтесь для этого функцией-членом remove (заметьте у вектора и двусторонней очереди такой функции-члена нет). 
Класс list содержит функцию член merge. Разберитесь для чего используется эта функция и приведите пример её использования.

## Задача 2
Создайте вектор А. Пусть А состоит из 4 элементов каждый из которых является вектором содержащим целые числа 0 и 1. Данный вектор A можно считать двумерным массивом или матрицей. Выведите элементы А на экран.

## Задача 3
Используйте вместо двумерных массивов (как Вы это сделали в задаче 2) массивы указателей. Создайте вектор указателей A. Каждый элемент вектора A, A[i] должен являться указателем на вектор из двух элементов целого типа. Доступ к этим элементам может осуществляться так: *(A[i])[j]. Выведите элементы А на экран. Не забудьте после завершения работы освободить память.

## Задача 4
Напишите функцию для нахождения пересечения двух множеств A  и B.   Прототип функции может иметь вид:
`typedef set<int, less<int> > type_set;`

type_set operator*(const type_set& A, const type_set& B);

Для пересечения множеств  используйте алгоритм set_intersection. Пример использования данного алгоритма приведен ниже (I – это результат пересечения множеств):

set_intersection(A.begin(), A.end(),   B.begin(),B.end(),inserter(I,I.begin()));
Поясните, что такое inserter(I,I.begin()).

## Задача 5
Напишите функцию для нахождения объединения двух множеств A  и B.   Прототип функции может иметь вид:
typedef set<int, less<int> > type_set;

type_set operator+(const type_set& A, const type_set& B);

Для объединения множеств  используйте алгоритм set_union. Пример использования данного алгоритма приведен ниже (I – это результат объединения множеств):

set_union(A.begin(), A.end(),   B.begin(),B.end(),inserter(I,I.begin()));
